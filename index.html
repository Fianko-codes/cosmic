<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>immersive solar system - fianko-codes</title>
    <style>
        body { 
            margin: 0; 
            overflow: hidden; 
            background: black;
            font-family: arial, sans-serif;
        }

        #controls {
            position: fixed;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            display: flex;
            gap: 10px;
            background: rgba(0, 0, 0, 0.8);
            padding: 15px;
            border-radius: 10px;
            border: 1px solid #0ff;
        }

        .btn {
            background: #0ff;
            border: none;
            padding: 8px 16px;
            border-radius: 5px;
            color: black;
            cursor: pointer;
            transition: all 0.3s;
            font-weight: bold;
        }

        .btn:hover {
            background: #00ffff80;
            transform: scale(1.05);
        }

        #timeScale {
            position: fixed;
            top: 20px;
            right: 20px;
            background: rgba(0, 0, 0, 0.8);
            padding: 15px;
            border-radius: 10px;
            border: 1px solid #0ff;
            color: #0ff;
            font-size: 14px;
        }

        #speedSlider {
            width: 150px;
            margin: 10px 0;
        }
    </style>
</head>
<body>
    <div id="controls">
        <button class="btn" id="toggleOrbits">toggle orbits</button>
        <button class="btn" id="toggleRotation">stop rotation</button>
        <button class="btn" id="resetCamera">reset view</button>
    </div>

    <div id="timeScale">
        time scale: <span id="timeValue">1x</span>
        <br>
        <input type="range" id="speedSlider" min="1" max="1000" value="1">
    </div>

    <script type="importmap">
        {
            "imports": {
                "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
                "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/"
            }
        }
    </script>
    <script type="module">
        import * as THREE from 'three';
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';

        // scene setup with enhanced far plane
        const scene = new THREE.Scene();
        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 2000);
        const renderer = new THREE.WebGLRenderer({ 
            antialias: true,
            logarithmicDepthBuffer: true  // better depth rendering
        });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(window.devicePixelRatio); // sharper rendering
        document.body.appendChild(renderer.domElement);

        // texture loader
        const textureLoader = new THREE.TextureLoader();

        // enhanced controls
        const controls = new OrbitControls(camera, renderer.domElement);
        controls.enableDamping = true;
        controls.dampingFactor = 0.05;
        controls.minDistance = 20;
        controls.maxDistance = 800;
        camera.position.set(0, 30, 100);
        controls.update();

        // enhanced lighting setup
        const ambientLight = new THREE.AmbientLight(0x666666);
        scene.add(ambientLight);
        
        const sunLight = new THREE.PointLight(0xffffff, 3.5);
        sunLight.position.set(0, 0, 0);
        scene.add(sunLight);

        const secondaryLight = new THREE.PointLight(0xffffff, 1);
        secondaryLight.position.set(100, 100, 100);
        scene.add(secondaryLight);

        // enhanced background stars
        const starGeometry = new THREE.BufferGeometry();
        const starVertices = [];
        for(let i = 0; i < 15000; i++) {
            const x = THREE.MathUtils.randFloatSpread(2000);
            const y = THREE.MathUtils.randFloatSpread(2000);
            const z = THREE.MathUtils.randFloatSpread(2000);
            starVertices.push(x, y, z);
        }
        starGeometry.setAttribute('position', new THREE.Float32BufferAttribute(starVertices, 3));
        const starMaterial = new THREE.PointsMaterial({ 
            color: 0xFFFFFF, 
            size: 1.2,
            transparent: true,
            opacity: 0.8
        });
        const stars = new THREE.Points(starGeometry, starMaterial);
        scene.add(stars);

        // enhanced planet data
        const planets = [
            {
                name: 'sun',
                radius: 12,  // bigger sun
                distance: 0,
                color: 0xffffff,
                emissive: true,
                period: 0,
                texture: 'sun.jpg',
                glowIntensity: 0.8
            },
            {
                name: 'mercury',
                radius: 2,  // increased sizes for better visibility
                distance: 25,
                color: 0xffffff,
                period: 88,
                texture: 'mercury.jpg'
            },
            {
                name: 'venus',
                radius: 2.8,
                distance: 40,
                color: 0xffffff,
                period: 225,
                texture: 'venus.jpg'
            },
            {
                name: 'earth',
                radius: 3,
                distance: 55,
                color: 0xffffff,
                period: 365.25,
                texture: 'earth.jpg',
                cloudsTexture: 'earth_clouds.jpg'
            },
            {
                name: 'mars',
                radius: 2.5,
                distance: 70,
                color: 0xffffff,
                period: 687,
                texture: 'mars.jpg'
            },
            {
                name: 'jupiter',
                radius: 6,
                distance: 95,
                color: 0xffffff,
                period: 4333,
                texture: 'jupiter.jpg'
            },
            {
                name: 'saturn',
                radius: 5,
                distance: 120,
                color: 0xffffff,
                period: 10759,
                texture: 'saturn.jpg',
                hasRings: true,
                ringsTexture: 'saturn_rings.png'
            },
            {
                name: 'uranus',
                radius: 4,
                distance: 150,
                color: 0xffffff,
                period: 30687,
                texture: 'uranus.jpg'
            },
            {
                name: 'neptune',
                radius: 4,
                distance: 180,
                color: 0xffffff,
                period: 60190,
                texture: 'neptune.jpg'
            }
        ];

        const planetObjects = [];
        const orbitLines = [];

        // enhanced planet creation
        planets.forEach((data, index) => {
            // create enhanced orbit lines
            if (index > 0) {
                const orbitGeometry = new THREE.RingGeometry(data.distance, data.distance + 0.2, 128);
                const orbitMaterial = new THREE.MeshBasicMaterial({
                    color: 0xffffff,
                    side: THREE.DoubleSide,
                    transparent: true,
                    opacity: 0.3
                });
                const orbit = new THREE.Mesh(orbitGeometry, orbitMaterial);
                orbit.rotation.x = Math.PI / 2;
                scene.add(orbit);
                orbitLines.push(orbit);
            }

            // create enhanced planets
            const geometry = new THREE.SphereGeometry(data.radius, 64, 64);
            const texture = textureLoader.load(data.texture);
            texture.anisotropy = renderer.capabilities.getMaxAnisotropy(); // sharper textures

            const material = new THREE.MeshPhongMaterial({
                map: texture,
                shininess: 25,
                emissiveIntensity: data.glowIntensity || 0
            });

            if (data.emissive) {
                material.emissiveMap = texture;
                material.emissive = new THREE.Color(0xffff80);
                material.emissiveIntensity = 0.8;
            }

            const planet = new THREE.Mesh(geometry, material);

            // enhanced earth clouds
            if (data.name === 'earth') {
                const cloudGeometry = new THREE.SphereGeometry(data.radius + 0.05, 64, 64);
                const cloudTexture = textureLoader.load(data.cloudsTexture);
                cloudTexture.anisotropy = renderer.capabilities.getMaxAnisotropy();
                const cloudMaterial = new THREE.MeshPhongMaterial({
                    map: cloudTexture,
                    transparent: true,
                    opacity: 0.8
                });
                const clouds = new THREE.Mesh(cloudGeometry, cloudMaterial);
                planet.add(clouds);
            }

            // enhanced saturn rings
            if (data.hasRings) {
                const ringGeometry = new THREE.RingGeometry(data.radius * 1.4, data.radius * 2.4, 128);
                const ringTexture = textureLoader.load(data.ringsTexture);
                ringTexture.anisotropy = renderer.capabilities.getMaxAnisotropy();
                const ringMaterial = new THREE.MeshBasicMaterial({
                    map: ringTexture,
                    side: THREE.DoubleSide,
                    transparent: true,
                    opacity: 0.9
                });
                const rings = new THREE.Mesh(ringGeometry, ringMaterial);
                rings.rotation.x = Math.PI / 2;
                planet.add(rings);
            }

            // add to scene with enhanced positioning
            const planetGroup = new THREE.Group();
            planet.position.x = data.distance;
            planetGroup.add(planet);
            scene.add(planetGroup);

            // enhanced orbital speeds
            const mercuryTime = 7;
            const baseSpeed = (2 * Math.PI) / (mercuryTime * 60);
            const speedFactor = data.period > 0 
                ? baseSpeed * (88 / data.period) 
                : 0;

            planetObjects.push({
                mesh: planet,
                group: planetGroup,
                rotationSpeed: 0.02,
                orbitSpeed: speedFactor
            });
        });

        // ui elements
        const toggleOrbitsBtn = document.getElementById('toggleOrbits');
        const toggleRotationBtn = document.getElementById('toggleRotation');
        const resetCameraBtn = document.getElementById('resetCamera');
        const speedSlider = document.getElementById('speedSlider');
        const timeValue = document.getElementById('timeValue');

        let rotationEnabled = true;
        let timeScale = 1;

        // enhanced event handlers
        speedSlider.addEventListener('input', (e) => {
            timeScale = parseInt(e.target.value);
            timeValue.textContent = timeScale + 'x';
        });

        toggleOrbitsBtn.addEventListener('click', () => {
            orbitLines.forEach(orbit => orbit.visible = !orbit.visible);
        });

        toggleRotationBtn.addEventListener('click', () => {
            rotationEnabled = !rotationEnabled;
            toggleRotationBtn.textContent = rotationEnabled ? 'stop rotation' : 'start rotation';
        });

        resetCameraBtn.addEventListener('click', () => {
            camera.position.set(0, 30, 100);
            camera.lookAt(0, 0, 0);
            controls.reset();
        });

        // enhanced animation loop
        function animate() {
            requestAnimationFrame(animate);

            if (rotationEnabled) {
                planetObjects.forEach(obj => {
                    obj.mesh.rotation.y += obj.rotationSpeed * timeScale;
                    obj.group.rotation.y += obj.orbitSpeed * timeScale;
                });
            }

            controls.update();
            renderer.render(scene, camera);
        }

        // enhanced window resize handler
        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(window.devicePixelRatio);
        });

        animate();
    </script>
</body>
</html>
