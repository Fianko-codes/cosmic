<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>immersive space explorer - fianko-codes</title>
    <link rel="stylesheet" href="styles.css">
</head>
<body>
    <div id="controls">
        <button class="btn" id="toggleOrbits">toggle orbits</button>
        <button class="btn" id="toggleRotation">stop rotation</button>
        <button class="btn" id="resetCamera">reset view</button>
        <button class="btn" id="showControls">show controls</button>
    </div>

    <div id="timeScale">
        time scale: <span id="timeValue">1x</span>
        <br>
        <input type="range" id="speedSlider" min="1" max="1000" value="1">
    </div>

    <div id="viewMode">
        <button class="btn" id="toggleView">Switch to First Person</button>
    </div>

    <div id="planetInfo">
        <h2>Planet Name</h2>
        <p class="planet-distance">Distance from Sun: </p>
        <p class="planet-speed">Orbital Period: </p>
        <p class="planet-size">Diameter: </p>
    </div>

    <div id="speedometer">
        Speed: <span id="currentSpeed">0</span> km/s
    </div>

    <div id="controls-help">
        <h2>Controls</h2>
        <p><span class="key">W</span> Move Forward</p>
        <p><span class="key">S</span> Move Backward</p>
        <p><span class="key">A</span> Move Left</p>
        <p><span class="key">D</span> Move Right</p>
        <p><span class="key">SPACE</span> Move Up</p>
        <p><span class="key">SHIFT</span> Move Down</p>
        <p><span class="key">Q</span> Roll Left</p>
        <p><span class="key">E</span> Roll Right</p>
        <p><span class="key">R</span> Increase Speed</p>
        <p><span class="key">F</span> Decrease Speed</p>
        <p><span class="key">ESC</span> Toggle Mouse Control</p>
        <p>Click on planets for information</p>
        <button class="btn" id="closeControls">Close</button>
    </div>

    <script type="importmap">
        {
            "imports": {
                "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
                "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/"
            }
        }
    </script>
    <script type="module">
        import * as THREE from 'three';
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
        import { PointerLockControls } from 'three/addons/controls/PointerLockControls.js';

        // scene setup
        const scene = new THREE.Scene();
        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 2000);
        const renderer = new THREE.WebGLRenderer({ 
            antialias: true,
            logarithmicDepthBuffer: true
        });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(window.devicePixelRatio);
        document.body.appendChild(renderer.domElement);

        // Controls setup
        let orbitControls = new OrbitControls(camera, renderer.domElement);
        let pointerControls = new PointerLockControls(camera, document.body);
        let activeControls = orbitControls;
        let isFirstPerson = false;
        let velocity = new THREE.Vector3();
        let moveSpeed = 0;
        const MAX_SPEED = 50;

        // Movement flags
        const moveState = {
            forward: false,
            backward: false,
            left: false,
            right: false,
            up: false,
            down: false,
            rollLeft: false,
            rollRight: false
        };

        // Textures
        const textureLoader = new THREE.TextureLoader();
        const spacedustTexture = textureLoader.load('space_dust.png');
        const asteroidTexture = textureLoader.load('asteroid.jpg');

        // Enhanced lighting
        const ambientLight = new THREE.AmbientLight(0x666666);
        scene.add(ambientLight);
        
        const sunLight = new THREE.PointLight(0xffffff, 3.5);
        scene.add(sunLight);

        const secondaryLight = new THREE.PointLight(0xffffff, 1);
        secondaryLight.position.set(100, 100, 100);
        scene.add(secondaryLight);

        // Space dust particles
        const dustGeometry = new THREE.BufferGeometry();
        const dustVertices = [];
        for(let i = 0; i < 5000; i++) {
            const x = THREE.MathUtils.randFloatSpread(2000);
            const y = THREE.MathUtils.randFloatSpread(2000);
            const z = THREE.MathUtils.randFloatSpread(2000);
            dustVertices.push(x, y, z);
        }
        dustGeometry.setAttribute('position', new THREE.Float32BufferAttribute(dustVertices, 3));
        const dustMaterial = new THREE.PointsMaterial({
            map: spacedustTexture,
            size: 3,
            transparent: true,
            opacity: 0.6,
            color: 0xaaaaaa
        });
        const spaceDust = new THREE.Points(dustGeometry, dustMaterial);
        scene.add(spaceDust);

        // Asteroid belt
        const asteroidBelt = new THREE.Group();
        const ASTEROID_COUNT = 1000;
        const BELT_RADIUS = 85;
        const BELT_WIDTH = 15;

        for(let i = 0; i < ASTEROID_COUNT; i++) {
            const angle = (i / ASTEROID_COUNT) * Math.PI * 2;
            const radius = BELT_RADIUS + THREE.MathUtils.randFloatSpread(BELT_WIDTH);
            const size = 0.1 + Math.random() * 0.3;
            
            const asteroidGeometry = new THREE.IcosahedronGeometry(size, 0);
            const asteroidMaterial = new THREE.MeshPhongMaterial({
                map: asteroidTexture,
                color: 0x888888
            });
            
            const asteroid = new THREE.Mesh(asteroidGeometry, asteroidMaterial);
            asteroid.position.x = Math.cos(angle) * radius;
            asteroid.position.z = Math.sin(angle) * radius;
            asteroid.position.y = THREE.MathUtils.randFloatSpread(BELT_WIDTH);
            asteroid.rotation.set(
                Math.random() * Math.PI,
                Math.random() * Math.PI,
                Math.random() * Math.PI
            );
            
            asteroidBelt.add(asteroid);
        }
        scene.add(asteroidBelt);

        // Planet data with additional information
        const planets = [
            {
                name: 'Sun',
                radius: 12,
                distance: 0,
                color: 0xffffff,
                emissive: true,
                period: 0,
                texture: 'sun.jpg',
                glowIntensity: 0.8,
                realDiameter: 1392684,
                info: "The Sun is our star and the source of light and heat for the solar system."
            },
            // ... (previous planet data) ...
        ];

                const planetObjects = [];
        const orbitLines = [];
        const planetColliders = []; // For collision detection

        // Create planets with enhanced features
        planets.forEach((data, index) => {
            // Create orbit lines
            if (index > 0) {
                const orbitGeometry = new THREE.RingGeometry(data.distance, data.distance + 0.2, 128);
                const orbitMaterial = new THREE.MeshBasicMaterial({
                    color: 0xffffff,
                    side: THREE.DoubleSide,
                    transparent: true,
                    opacity: 0.3
                });
                const orbit = new THREE.Mesh(orbitGeometry, orbitMaterial);
                orbit.rotation.x = Math.PI / 2;
                scene.add(orbit);
                orbitLines.push(orbit);
            }

            // Create planet with enhanced materials
            const geometry = new THREE.SphereGeometry(data.radius, 64, 64);
            const texture = textureLoader.load(data.texture);
            texture.anisotropy = renderer.capabilities.getMaxAnisotropy();

            const material = new THREE.MeshPhongMaterial({
                map: texture,
                shininess: 25,
                emissiveIntensity: data.glowIntensity || 0
            });

            if (data.emissive) {
                material.emissiveMap = texture;
                material.emissive = new THREE.Color(0xffff80);
                material.emissiveIntensity = 0.8;
            }

            const planet = new THREE.Mesh(geometry, material);
            planet.userData = {
                name: data.name,
                distance: data.distance,
                period: data.period,
                realDiameter: data.realDiameter,
                info: data.info
            };

            // Collision sphere (invisible)
            const colliderGeometry = new THREE.SphereGeometry(data.radius + 1);
            const colliderMaterial = new THREE.MeshBasicMaterial({
                visible: false
            });
            const collider = new THREE.Mesh(colliderGeometry, colliderMaterial);
            collider.position.copy(planet.position);
            planetColliders.push(collider);
            scene.add(collider);

            // Add enhanced Earth clouds
            if (data.name === 'Earth') {
                const cloudGeometry = new THREE.SphereGeometry(data.radius + 0.05, 64, 64);
                const cloudTexture = textureLoader.load(data.cloudsTexture);
                cloudTexture.anisotropy = renderer.capabilities.getMaxAnisotropy();
                const cloudMaterial = new THREE.MeshPhongMaterial({
                    map: cloudTexture,
                    transparent: true,
                    opacity: 0.8
                });
                const clouds = new THREE.Mesh(cloudGeometry, cloudMaterial);
                planet.add(clouds);
            }

            // Enhanced Saturn rings
            if (data.hasRings) {
                const ringGeometry = new THREE.RingGeometry(data.radius * 1.4, data.radius * 2.4, 128);
                const ringTexture = textureLoader.load(data.ringsTexture);
                ringTexture.anisotropy = renderer.capabilities.getMaxAnisotropy();
                const ringMaterial = new THREE.MeshBasicMaterial({
                    map: ringTexture,
                    side: THREE.DoubleSide,
                    transparent: true,
                    opacity: 0.9
                });
                const rings = new THREE.Mesh(ringGeometry, ringMaterial);
                rings.rotation.x = Math.PI / 2;
                planet.add(rings);
            }

            const planetGroup = new THREE.Group();
            planet.position.x = data.distance;
            planetGroup.add(planet);
            scene.add(planetGroup);

            const mercuryTime = 7;
            const baseSpeed = (2 * Math.PI) / (mercuryTime * 60);
            const speedFactor = data.period > 0 
                ? baseSpeed * (88 / data.period) 
                : 0;

            planetObjects.push({
                mesh: planet,
                group: planetGroup,
                collider: collider,
                rotationSpeed: 0.02,
                orbitSpeed: speedFactor
            });
        });

        // Raycaster for planet interaction
        const raycaster = new THREE.Raycaster();
        const mouse = new THREE.Vector2();

        // UI Elements
        const toggleOrbitsBtn = document.getElementById('toggleOrbits');
        const toggleRotationBtn = document.getElementById('toggleRotation');
        const resetCameraBtn = document.getElementById('resetCamera');
        const speedSlider = document.getElementById('speedSlider');
        const timeValue = document.getElementById('timeValue');
        const toggleViewBtn = document.getElementById('toggleView');
        const planetInfo = document.getElementById('planetInfo');
        const showControlsBtn = document.getElementById('showControls');
        const closeControlsBtn = document.getElementById('closeControls');
        const controlsHelp = document.getElementById('controls-help');
        const speedometer = document.getElementById('speedometer');
        const currentSpeed = document.getElementById('currentSpeed');

        let rotationEnabled = true;
        let timeScale = 1;

        // Enhanced event handlers
        speedSlider.addEventListener('input', (e) => {
            timeScale = parseInt(e.target.value);
            timeValue.textContent = timeScale + 'x';
        });

        toggleOrbitsBtn.addEventListener('click', () => {
            orbitLines.forEach(orbit => orbit.visible = !orbit.visible);
        });

        toggleRotationBtn.addEventListener('click', () => {
            rotationEnabled = !rotationEnabled;
            toggleRotationBtn.textContent = rotationEnabled ? 'stop rotation' : 'start rotation';
        });

        resetCameraBtn.addEventListener('click', () => {
            if (isFirstPerson) {
                camera.position.set(0, 30, 100);
                camera.lookAt(0, 0, 0);
            } else {
                camera.position.set(0, 30, 100);
                orbitControls.target.set(0, 0, 0);
                orbitControls.update();
            }
        });

        // View mode switching
        toggleViewBtn.addEventListener('click', () => {
            isFirstPerson = !isFirstPerson;
            if (isFirstPerson) {
                orbitControls.enabled = false;
                pointerControls.lock();
                speedometer.style.display = 'block';
                toggleViewBtn.textContent = 'Switch to Orbit View';
            } else {
                pointerControls.unlock();
                orbitControls.enabled = true;
                speedometer.style.display = 'none';
                toggleViewBtn.textContent = 'Switch to First Person';
            }
        });

        // Controls help
        showControlsBtn.addEventListener('click', () => {
            controlsHelp.classList.add('visible');
        });

        closeControlsBtn.addEventListener('click', () => {
            controlsHelp.classList.remove('visible');
        });

        // Planet interaction
        renderer.domElement.addEventListener('click', (event) => {
            if (isFirstPerson) return;

            mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
            mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;

            raycaster.setFromCamera(mouse, camera);
            const intersects = raycaster.intersectObjects(
                planetObjects.map(obj => obj.mesh)
            );

            if (intersects.length > 0) {
                const planet = intersects[0].object;
                const info = planet.userData;
                
                planetInfo.querySelector('h2').textContent = info.name;
                planetInfo.querySelector('.planet-distance').textContent = 
                    `Distance from Sun: ${info.distance} million km`;
                planetInfo.querySelector('.planet-speed').textContent = 
                    `Orbital Period: ${info.period} Earth days`;
                planetInfo.querySelector('.planet-size').textContent = 
                    `Diameter: ${info.realDiameter} km`;
                
                planetInfo.style.display = 'block';
            } else {
                planetInfo.style.display = 'none';
            }
        });

        // First person controls
        document.addEventListener('keydown', (event) => {
            if (isFirstPerson) {
                switch (event.code) {
                    case 'KeyW': moveState.forward = true; break;
                    case 'KeyS': moveState.backward = true; break;
                    case 'KeyA': moveState.left = true; break;
                    case 'KeyD': moveState.right = true; break;
                    case 'Space': moveState.up = true; break;
                    case 'ShiftLeft': moveState.down = true; break;
                    case 'KeyQ': moveState.rollLeft = true; break;
                    case 'KeyE': moveState.rollRight = true; break;
                    case 'KeyR': moveSpeed = Math.min(moveSpeed + 1, MAX_SPEED); break;
                    case 'KeyF': moveSpeed = Math.max(moveSpeed - 1, 0); break;
                }
            }
        });

        document.addEventListener('keyup', (event) => {
            if (isFirstPerson) {
                switch (event.code) {
                    case 'KeyW': moveState.forward = false; break;
                    case 'KeyS': moveState.backward = false; break;
                    case 'KeyA': moveState.left = false; break;
                    case 'KeyD': moveState.right = false; break;
                    case 'Space': moveState.up = false; break;
                    case 'ShiftLeft': moveState.down = false; break;
                    case 'KeyQ': moveState.rollLeft = false; break;
                    case 'KeyE': moveState.rollRight = false; break;
                }
            }
        });

        // Collision detection
        function checkCollisions() {
            const cameraPosition = camera.position.clone();
            const cameraDirection = new THREE.Vector3();
            camera.getWorldDirection(cameraDirection);

            for (let obj of planetObjects) {
                const distance = cameraPosition.distanceTo(obj.collider.position);
                if (distance < obj.collider.geometry.parameters.radius + 2) {
                    // Push camera away from planet
                    const pushVector = cameraPosition.clone().sub(obj.collider.position).normalize();
                    camera.position.add(pushVector.multiplyScalar(0.5));
                    moveSpeed *= 0.5; // Reduce speed on collision
                }
            }
        }

        // Enhanced animation loop
        function animate() {
            requestAnimationFrame(animate);

            if (rotationEnabled) {
                planetObjects.forEach(obj => {
                    obj.mesh.rotation.y += obj.rotationSpeed * timeScale;
                    obj.group.rotation.y += obj.orbitSpeed * timeScale;
                    obj.collider.position.copy(obj.mesh.getWorldPosition(new THREE.Vector3()));
                });
                asteroidBelt.rotation.y += 0.0005 * timeScale;
            }

            // First person movement
            if (isFirstPerson) {
                const delta = 0.1;
                
                if (moveState.forward) velocity.z = -moveSpeed * delta;
                if (moveState.backward) velocity.z = moveSpeed * delta;
                if (moveState.left) velocity.x = -moveSpeed * delta;
                if (moveState.right) velocity.x = moveSpeed * delta;
                if (moveState.up) velocity.y = moveSpeed * delta;
                if (moveState.down) velocity.y = -moveSpeed * delta;
                
                if (moveState.rollLeft) camera.rotateZ(0.02);
                if (moveState.rollRight) camera.rotateZ(-0.02);

                pointerControls.moveForward(-velocity.z);
                pointerControls.moveRight(velocity.x);
                camera.position.y += velocity.y;

                velocity.multiplyScalar(0.95); // Add inertia
                checkCollisions();
                
                currentSpeed.textContent = Math.round(moveSpeed);
            }

            controls.update();
            renderer.render(scene, camera);
        }

        // Enhanced window resize handler
        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(window.devicePixelRatio);
        });

        animate();
    </script>
</body>
</html>
